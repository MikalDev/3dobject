"use strict"
{
  const C3 = self.C3

  C3.Plugins.Mikal_3DObject = class Object3DPlugin extends C3.SDKPluginBase {
    constructor(opts) {
      super(opts)
      console.log("opts", opts)
      const C3 = self.C3
      const runtime = opts.runtime
      const MAX_BONES = 256;
      const _DUMMY_UBO_SIZE = MAX_BONES * 16 * 4;

      if (!globalThis.vertexShaderGPUSkinningEnabledXYZ) {
        globalThis.vertexShaderGPUSkinningEnabledXYZ = true
        // Choose a binding point for the bones UBO. Using a high number
        // to reduce potential conflicts with C3's internal bindings.
        globalThis.bonesBindingPoint = 0
        globalThis.dummyBonesUboBuffer = null

        // In the C3 runtime, we can get the renderer from the runtime instance.
        // However, the plugin instance isn't available here. We can listen for
        // the "afterfirstlayoutstart" event to get the runtime and renderer.
        runtime._iRuntime.addEventListener("afterprojectstart", () => {
          const renderer = runtime.GetCanvasManager().GetRenderer()
          const gl = renderer._gl

          if (gl && !globalThis.dummyBonesUboBuffer) {
            // Create a dummy UBO buffer once and bind it.
            // This buffer will be used by default for any shader program
            // that has the "Bones" uniform block.
            const dummyData = new Float32Array(_DUMMY_UBO_SIZE) // A single mat4 is enough.
            const uboBuffer = gl.createBuffer()
            gl.bindBuffer(gl.UNIFORM_BUFFER, uboBuffer)
            gl.bufferData(gl.UNIFORM_BUFFER, dummyData, gl.STATIC_DRAW)
            gl.bindBuffer(gl.UNIFORM_BUFFER, null)

            globalThis.dummyBonesUboBuffer = uboBuffer

            // Bind the dummy buffer to the chosen binding point.
            // This binding will persist until another buffer is bound to this point.
            gl.bindBufferBase(
              gl.UNIFORM_BUFFER,
              globalThis.bonesBindingPoint,
              globalThis.dummyBonesUboBuffer
            )
            console.info("[3DObject] Dummy UBO for bones created and bound.")
          }
        })

        function GetDefaultVertexShaderSource_WebGL2(useHighP) {
          const texPrecision = useHighP ? "highp" : "mediump"
          return [
            `#version 300 es`,
            `// Increased max bones for UBO`,
            `const int MAX_BONES = 256;`,

            `in highp vec3 aPos;`,
            `in highp vec2 aTex;`,
            `in lowp vec4 aColor;`,
            `in highp vec3 aNormal;`,
            `out highp vec2 vTex;`,
            `out highp vec2 vNPTex;`,
            `out highp float vNPW;`,
            `out lowp vec4 vColor;`,
            `out highp vec3 vNormal;`,
            `uniform highp mat4 matP;`,
            `uniform highp mat4 matMV;`,
            `in vec4 aWeights;`,
            `in vec4 aJoints;`,
            `out highp vec3 pos;`,
            `out highp vec3 vVertexLighting;`,
            `uniform highp mat4 uModelRotate;`,
            `uniform mat4 uRootNodeXform;`,
            `uniform mat4 uNodeXform;`,
            `uniform float uSkinEnable;`,
            `uniform float uNodeXformEnable;`,
            `uniform float uModelRotateEnable;`,
            `uniform float uUVXformEnable;`,
            `uniform vec2 uUVOffset;`,
            `uniform mat2 uUVRotate;`,
            `uniform vec2 uUVRotateCenter;`,
            `uniform float uPhongEnable;`,
            `uniform float uNPUVEnable;`,
            `uniform highp mat4 uNormalMatrix;`,
            `uniform highp mat4 uNormalMatrixSkinned;`,
            `uniform highp mat4 uNormalMatrixNode;`,
            `uniform float uHasVertexColors;`,
            `uniform float uUseUniformColor;`,
            `uniform lowp vec4 uObjectColor;`,
            `uniform highp float uVertexLightEnable;`,
            `uniform highp float uVertexLightDebug;`,
            `// --- Light 0 uniforms for vertex lighting ---`,
            `uniform lowp float uEnable0;`,
            `uniform lowp vec3 uColor0;`,
            `uniform highp float uBrightness0;`,
            `uniform highp float uPosX0;`,
            `uniform highp float uPosY0;`,
            `uniform highp float uPosZ0;`,
            `uniform highp float uSpotAngle0;`,
            `uniform highp float uSpotEdge0;`,
            `uniform highp float uSpotDirX0;`,
            `uniform highp float uSpotDirY0;`,
            `uniform highp float uSpotDirZ0;`,
            `uniform highp float uAttenConstant0;`,
            `uniform highp float uAttenLinear0;`,
            `uniform highp float uAttenQuadratic0;`,
            `// --- Light 1 uniforms ---`,
            `uniform lowp float uEnable1;`,
            `uniform lowp vec3 uColor1;`,
            `uniform highp float uBrightness1;`,
            `uniform highp float uPosX1;`,
            `uniform highp float uPosY1;`,
            `uniform highp float uPosZ1;`,
            `uniform highp float uSpotAngle1;`,
            `uniform highp float uSpotEdge1;`,
            `uniform highp float uSpotDirX1;`,
            `uniform highp float uSpotDirY1;`,
            `uniform highp float uSpotDirZ1;`,
            `uniform highp float uAttenConstant1;`,
            `uniform highp float uAttenLinear1;`,
            `uniform highp float uAttenQuadratic1;`,
            `// --- Light 2 uniforms ---`,
            `uniform lowp float uEnable2;`,
            `uniform lowp vec3 uColor2;`,
            `uniform highp float uBrightness2;`,
            `uniform highp float uPosX2;`,
            `uniform highp float uPosY2;`,
            `uniform highp float uPosZ2;`,
            `uniform highp float uSpotAngle2;`,
            `uniform highp float uSpotEdge2;`,
            `uniform highp float uSpotDirX2;`,
            `uniform highp float uSpotDirY2;`,
            `uniform highp float uSpotDirZ2;`,
            `uniform highp float uAttenConstant2;`,
            `uniform highp float uAttenLinear2;`,
            `uniform highp float uAttenQuadratic2;`,
            `// --- Light 3 uniforms ---`,
            `uniform lowp float uEnable3;`,
            `uniform lowp vec3 uColor3;`,
            `uniform highp float uBrightness3;`,
            `uniform highp float uPosX3;`,
            `uniform highp float uPosY3;`,
            `uniform highp float uPosZ3;`,
            `uniform highp float uSpotAngle3;`,
            `uniform highp float uSpotEdge3;`,
            `uniform highp float uSpotDirX3;`,
            `uniform highp float uSpotDirY3;`,
            `uniform highp float uSpotDirZ3;`,
            `uniform highp float uAttenConstant3;`,
            `uniform highp float uAttenLinear3;`,
            `uniform highp float uAttenQuadratic3;`,
            `// --- Light 4 uniforms ---`,
            `uniform lowp float uEnable4;`,
            `uniform lowp vec3 uColor4;`,
            `uniform highp float uBrightness4;`,
            `uniform highp float uPosX4;`,
            `uniform highp float uPosY4;`,
            `uniform highp float uPosZ4;`,
            `uniform highp float uSpotAngle4;`,
            `uniform highp float uSpotEdge4;`,
            `uniform highp float uSpotDirX4;`,
            `uniform highp float uSpotDirY4;`,
            `uniform highp float uSpotDirZ4;`,
            `uniform highp float uAttenConstant4;`,
            `uniform highp float uAttenLinear4;`,
            `uniform highp float uAttenQuadratic4;`,
            `// --- Light 5 uniforms ---`,
            `uniform lowp float uEnable5;`,
            `uniform lowp vec3 uColor5;`,
            `uniform highp float uBrightness5;`,
            `uniform highp float uPosX5;`,
            `uniform highp float uPosY5;`,
            `uniform highp float uPosZ5;`,
            `uniform highp float uSpotAngle5;`,
            `uniform highp float uSpotEdge5;`,
            `uniform highp float uSpotDirX5;`,
            `uniform highp float uSpotDirY5;`,
            `uniform highp float uSpotDirZ5;`,
            `uniform highp float uAttenConstant5;`,
            `uniform highp float uAttenLinear5;`,
            `uniform highp float uAttenQuadratic5;`,
            `// --- Light 6 uniforms ---`,
            `uniform lowp float uEnable6;`,
            `uniform lowp vec3 uColor6;`,
            `uniform highp float uBrightness6;`,
            `uniform highp float uPosX6;`,
            `uniform highp float uPosY6;`,
            `uniform highp float uPosZ6;`,
            `uniform highp float uSpotAngle6;`,
            `uniform highp float uSpotEdge6;`,
            `uniform highp float uSpotDirX6;`,
            `uniform highp float uSpotDirY6;`,
            `uniform highp float uSpotDirZ6;`,
            `uniform highp float uAttenConstant6;`,
            `uniform highp float uAttenLinear6;`,
            `uniform highp float uAttenQuadratic6;`,
            `// --- Light 7 uniforms ---`,
            `uniform lowp float uEnable7;`,
            `uniform lowp vec3 uColor7;`,
            `uniform highp float uBrightness7;`,
            `uniform highp float uPosX7;`,
            `uniform highp float uPosY7;`,
            `uniform highp float uPosZ7;`,
            `uniform highp float uSpotAngle7;`,
            `uniform highp float uSpotEdge7;`,
            `uniform highp float uSpotDirX7;`,
            `uniform highp float uSpotDirY7;`,
            `uniform highp float uSpotDirZ7;`,
            `uniform highp float uAttenConstant7;`,
            `uniform highp float uAttenLinear7;`,
            `uniform highp float uAttenQuadratic7;`,
            `// --- Directional light uniforms ---`,
            `uniform highp float uDirectionalEnable;`,
            `uniform highp vec3 uDirectionalColor;`,
            `uniform highp float uDirectionalBrightness;`,
            `uniform highp float uDirectionalDirX;`,
            `uniform highp float uDirectionalDirY;`,
            `uniform highp float uDirectionalDirZ;`,
            `uniform lowp vec3 uAmbientColor;`,
            `// --- Specular uniforms ---`,
            `uniform highp float uSpecularEnable;`,
            `uniform highp vec3 uSpecularColor;`,
            `uniform highp float uShininess;`,
            `uniform highp float uSpecularIntensity;`,
            `uniform highp vec3 uViewPosition;`,
            `// --- Uniform Block for Bone Matrices ---`,
            `layout(std140) uniform Bones {`,
            `    mat4 uBones[MAX_BONES];`,
            `};`,
            `// --- End Uniform Block ---`,

            `// --- REMOVED Bone Texture Uniforms & Function ---`,

            `void main(void) {`,
            `    pos = aPos;`,
            `    highp float wrap = 0.5;`,
            `    vNormal = aNormal;`, // Default normal
            `    if (uSkinEnable > 0.5) {`,
            `        // Skinning is enabled`,
            `        highp vec4 skinVertex = vec4(0.0);`,
            `        highp vec3 skinnedNormal = vec3(0.0);`,
            `        for (int i = 0; i < 4; i++) {`,
            `            int joint = int(aJoints[i]);`,
            `            // Access bone matrix directly from UBO`,
            `            mat4 boneMatrix = uBones[joint];`,
            `            skinVertex += aWeights[i] * (boneMatrix * vec4(aPos, 1.0));`,
            `            if (uPhongEnable > 0.5) {`,
            `                skinnedNormal += aWeights[i] * (mat3(boneMatrix) * aNormal);`, // Apply skinning to normals
            `            }`,
            `        }`,
            `        highp vec4 position = matP * matMV * uRootNodeXform * skinVertex;`,
            `        pos = (uModelRotate * uRootNodeXform * skinVertex).xyz;`,
            `        gl_Position = position;`,
            `        if (uPhongEnable > 0.5) {`,
            `            // Use pre-computed normal matrix for better performance`,
            `            vNormal = mat3(uNormalMatrixSkinned) * skinnedNormal;`, // Use skinned normal
            `            vNormal.x = -vNormal.x;`,
            `        }`,
            `    } else if (uNodeXformEnable > 0.5) {`,
            `        // Apply simple animation using the new transformation matrix`,
            `        pos = (uModelRotate * uNodeXform * vec4(aPos, 1.0)).xyz;`,
            `        gl_Position = matP * matMV * uNodeXform * vec4(aPos, 1.0);`,
            `        if (uPhongEnable > 0.5) {`,
            `            // Use pre-computed normal matrix for better performance`,
            `            vNormal = mat3(uNormalMatrixNode) * aNormal;`, // Adjust normal for node transform
            `            vNormal.x = -vNormal.x;`,
            `        }`,
            `    } else if (uModelRotateEnable > 0.5) {`,
            `        // Apply simple animation using the new transformation matrix`,
            `        highp vec4 rotatedPos = uModelRotate * vec4(aPos, 1.0);`,
            `        pos = rotatedPos.xyz;`,
            `        gl_Position = matP * matMV * vec4(aPos, 1.0);`,
            `        if (uPhongEnable > 0.5) {`,
            `            vNormal = mat3(uNormalMatrix) * aNormal;`, // Adjust normal for model rotation
            `            vNormal.x = -vNormal.x;`,
            `        }`,
            `    } else {`,
            `    	    pos = aPos;`,
            `	        gl_Position = matP * matMV * vec4(aPos, 1.0);`,
            `          if (uPhongEnable > 0.5) {`,
            `              vNormal = aNormal;`, // Default normal
            `          }`,
            `    }`,
            `    if (uUVXformEnable > 0.5) {`,
            `        vec2 uv = aTex;`,
            `        vec2 uvCentered = uv - uUVRotateCenter;`,
            `        vec2 rotatedUV = uUVRotate * uvCentered;`,
            `        rotatedUV = rotatedUV + uUVRotateCenter;`,
            `        rotatedUV.x = rotatedUV.x + uUVOffset.x;`,
            `        rotatedUV.y = rotatedUV.y + uUVOffset.y;`,
            `        vTex = rotatedUV;`,
            `        vNPTex = aTex * gl_Position.w;`,
            `        vNPW = gl_Position.w;`,
            `    } else {`,
            `        vTex = aTex;`,
            `        vNPTex = aTex * gl_Position.w;`,
            `        vNPW = gl_Position.w;`,
            `    }`,
            `    // Enhanced vertex color handling for 3DObject compatibility`,
            `    if (uUseUniformColor > 0.5) {`,
            `        // 3DObject mode: combine model colors with instance tint`,
            `        if (uHasVertexColors > 0.5) {`,
            `            vColor = aColor * uObjectColor;  // Model colors Ã— instance tint`,
            `        } else {`,
            `            vColor = uObjectColor;           // No model colors, use tint only`,
            `        }`,
            `    } else {`,
            `        // Standard C3 mode: use vertex buffer colors`,
            `        // Default to using vertex colors, only disable when explicitly set to 0`,
            `        vColor = aColor;  // Always use vertex colors in standard C3 mode`,
            `    }`,
            ``,
            `    // Initialize vertex lighting output`,
            `    vVertexLighting = vec3(0.0, 0.0, 0.0);`,
            ``,
            `    // Debug mode: visualize normals as colors`,
            `    if (uVertexLightDebug > 0.5) {`,
            `        // Use the final transformed normal for visualization`,
            `        // Map normal components from [-1,1] to [0,1] for RGB visualization`,
            `        vVertexLighting = (vNormal + 1.0) * 0.5;`,
            `    } else if (uVertexLightEnable > 0.5) {`,
            `        vNormal = vec3(vNormal.x, -vNormal.y, -vNormal.z);`,
            `        vNormal = normalize(vNormal);`,
            `        highp vec3 lightNormal = vNormal;`,
            `        // Vertex lighting calculation`,
            `        highp vec3 sumColor = uAmbientColor;`,
            `        highp vec3 specularSum = vec3(0.0);`,
            `        // Use normalized normal directly for lighting calculations`,
            `        // Calculate view direction once for all lights`,
            `        highp vec3 viewDir = normalize(uViewPosition - pos);`,
            `        // Light 0 (spotlight)`,
            `        if (uEnable0 != 0.0) {`,
            `            highp vec3 lightPos = vec3(uPosX0, uPosY0, uPosZ0);`,
            `            highp vec3 spotDir = vec3(uSpotDirX0, uSpotDirY0, uSpotDirZ0);`,
            `            highp vec3 lightDir = pos - lightPos;`,
            `            highp float lightDist = length(lightDir);`,
            `            lightDir = normalize(lightDir);`,
            `            spotDir = normalize(spotDir);`,
            `            `,
            `            // Calculate diffuse lighting (match fragment shader: no negation)`,
            `            highp float dotNL = dot(lightNormal, lightDir);`,
            `            highp float light = dotNL * (1.0-wrap) + wrap;`,
            `            light = light * light;`,
            `            `,
            `            // Calculate spotlight cone attenuation`,
            `            highp float cutoff = uSpotAngle0;`,
            `            highp float edge = uSpotEdge0;`,
            `            highp float spot = dot(spotDir, lightDir);`,
            `            spot = spot < cutoff ? smoothstep(cutoff * (1.0 - edge), cutoff, spot) : 1.0;`,
            `            light = light * spot;`,
            `            `,
            `            // Apply distance attenuation`,
            `            light = light / ((1.0 + uAttenConstant0) + lightDist * uAttenLinear0 + lightDist * lightDist * uAttenQuadratic0);`,
            `            `,
            `            // Accumulate light contribution`,
            `            sumColor = sumColor + light * uColor0 * uBrightness0;`,
            `            `,
            `            // Calculate specular if enabled`,
            `            if (uSpecularEnable > 0.5) {`,
            `                highp vec3 reflectDir = reflect(-lightDir, lightNormal);`,
            `                highp float spec = pow(max(dot(viewDir, reflectDir), 0.0), uShininess);`,
            `                specularSum += uSpecularIntensity * spec * spot / ((1.0 + uAttenConstant0) + lightDist * uAttenLinear0 + lightDist * lightDist * uAttenQuadratic0);`,
            `            }`,
            `        }`,
            `        `,
            `        // Light 1 (spotlight)`,
            `        if (uEnable1 != 0.0) {`,
            `            highp vec3 lightPos = vec3(uPosX1, uPosY1, uPosZ1);`,
            `            highp vec3 spotDir = vec3(uSpotDirX1, uSpotDirY1, uSpotDirZ1);`,
            `            highp vec3 lightDir = pos - lightPos;`,
            `            highp float lightDist = length(lightDir);`,
            `            lightDir = normalize(lightDir);`,
            `            spotDir = normalize(spotDir);`,
            `            `,
            `            // Calculate diffuse lighting (match fragment shader: no negation)`,
            `            highp float dotNL = dot(lightNormal, lightDir);`,
            `            highp float light = dotNL * (1.0-wrap) + wrap;`,
            `            light = light * light;`,
            `            `,
            `            // Calculate spotlight cone attenuation`,
            `            highp float cutoff = uSpotAngle1;`,
            `            highp float edge = uSpotEdge1;`,
            `            highp float spot = dot(spotDir, lightDir);`,
            `            spot = spot < cutoff ? smoothstep(cutoff * (1.0 - edge), cutoff, spot) : 1.0;`,
            `            light = light * spot;`,
            `            `,
            `            // Apply distance attenuation`,
            `            light = light / ((1.0 + uAttenConstant1) + lightDist * uAttenLinear1 + lightDist * lightDist * uAttenQuadratic1);`,
            `            `,
            `            // Accumulate light contribution`,
            `            sumColor = sumColor + light * uColor1 * uBrightness1;`,
            `            `,
            `            // Calculate specular if enabled`,
            `            if (uSpecularEnable > 0.5) {`,
            `                highp vec3 reflectDir = reflect(-lightDir, lightNormal);`,
            `                highp float spec = pow(max(dot(viewDir, reflectDir), 0.0), uShininess);`,
            `                specularSum += uSpecularIntensity * spec * spot / ((1.0 + uAttenConstant1) + lightDist * uAttenLinear1 + lightDist * lightDist * uAttenQuadratic1);`,
            `            }`,
            `        }`,
            `        `,
            `        // Light 2 (spotlight)`,
            `        if (uEnable2 != 0.0) {`,
            `            highp vec3 lightPos = vec3(uPosX2, uPosY2, uPosZ2);`,
            `            highp vec3 spotDir = vec3(uSpotDirX2, uSpotDirY2, uSpotDirZ2);`,
            `            highp vec3 lightDir = pos - lightPos;`,
            `            highp float lightDist = length(lightDir);`,
            `            lightDir = normalize(lightDir);`,
            `            spotDir = normalize(spotDir);`,
            `            `,
            `            // Calculate diffuse lighting (match fragment shader: no negation)`,
            `            highp float dotNL = dot(lightNormal, lightDir);`,
            `            highp float light = dotNL * (1.0-wrap) + wrap;`,
            `            light = light * light;`,
            `            `,
            `            // Calculate spotlight cone attenuation`,
            `            highp float cutoff = uSpotAngle2;`,
            `            highp float edge = uSpotEdge2;`,
            `            highp float spot = dot(spotDir, lightDir);`,
            `            spot = spot < cutoff ? smoothstep(cutoff * (1.0 - edge), cutoff, spot) : 1.0;`,
            `            light = light * spot;`,
            `            `,
            `            // Apply distance attenuation`,
            `            light = light / ((1.0 + uAttenConstant2) + lightDist * uAttenLinear2 + lightDist * lightDist * uAttenQuadratic2);`,
            `            `,
            `            // Accumulate light contribution`,
            `            sumColor = sumColor + light * uColor2 * uBrightness2;`,
            `            `,
            `            // Calculate specular if enabled`,
            `            if (uSpecularEnable > 0.5) {`,
            `                highp vec3 reflectDir = reflect(-lightDir, lightNormal);`,
            `                highp float spec = pow(max(dot(viewDir, reflectDir), 0.0), uShininess);`,
            `                specularSum += uSpecularIntensity * spec * spot / ((1.0 + uAttenConstant2) + lightDist * uAttenLinear2 + lightDist * lightDist * uAttenQuadratic2);`,
            `            }`,
            `        }`,
            `        `,
            `        // Light 3 (spotlight)`,
            `        if (uEnable3 != 0.0) {`,
            `            highp vec3 lightPos = vec3(uPosX3, uPosY3, uPosZ3);`,
            `            highp vec3 spotDir = vec3(uSpotDirX3, uSpotDirY3, uSpotDirZ3);`,
            `            highp vec3 lightDir = pos - lightPos;`,
            `            highp float lightDist = length(lightDir);`,
            `            lightDir = normalize(lightDir);`,
            `            spotDir = normalize(spotDir);`,
            `            `,
            `            // Calculate diffuse lighting (match fragment shader: no negation)`,
            `            highp float dotNL = dot(lightNormal, lightDir);`,
            `            highp float light = dotNL * (1.0-wrap) + wrap;`,
            `            light = light * light;`,
            `            `,
            `            // Calculate spotlight cone attenuation`,
            `            highp float cutoff = uSpotAngle3;`,
            `            highp float edge = uSpotEdge3;`,
            `            highp float spot = dot(spotDir, lightDir);`,
            `            spot = spot < cutoff ? smoothstep(cutoff * (1.0 - edge), cutoff, spot) : 1.0;`,
            `            light = light * spot;`,
            `            `,
            `            // Apply distance attenuation`,
            `            light = light / ((1.0 + uAttenConstant3) + lightDist * uAttenLinear3 + lightDist * lightDist * uAttenQuadratic3);`,
            `            `,
            `            // Accumulate light contribution`,
            `            sumColor = sumColor + light * uColor3 * uBrightness3;`,
            `            `,
            `            // Calculate specular if enabled`,
            `            if (uSpecularEnable > 0.5) {`,
            `                highp vec3 reflectDir = reflect(-lightDir, lightNormal);`,
            `                highp float spec = pow(max(dot(viewDir, reflectDir), 0.0), uShininess);`,
            `                specularSum += uSpecularIntensity * spec * spot / ((1.0 + uAttenConstant3) + lightDist * uAttenLinear3 + lightDist * lightDist * uAttenQuadratic3);`,
            `            }`,
            `        }`,
            `        `,
            `        // Light 4 (spotlight)`,
            `        if (uEnable4 != 0.0) {`,
            `            highp vec3 lightPos = vec3(uPosX4, uPosY4, uPosZ4);`,
            `            highp vec3 spotDir = vec3(uSpotDirX4, uSpotDirY4, uSpotDirZ4);`,
            `            highp vec3 lightDir = pos - lightPos;`,
            `            highp float lightDist = length(lightDir);`,
            `            lightDir = normalize(lightDir);`,
            `            spotDir = normalize(spotDir);`,
            `            `,
            `            // Calculate diffuse lighting (match fragment shader: no negation)`,
            `            highp float dotNL = dot(lightNormal, lightDir);`,
            `            highp float light = dotNL * (1.0-wrap) + wrap;`,
            `            light = light * light;`,
            `            `,
            `            // Calculate spotlight cone attenuation`,
            `            highp float cutoff = uSpotAngle4;`,
            `            highp float edge = uSpotEdge4;`,
            `            highp float spot = dot(spotDir, lightDir);`,
            `            spot = spot < cutoff ? smoothstep(cutoff * (1.0 - edge), cutoff, spot) : 1.0;`,
            `            light = light * spot;`,
            `            `,
            `            // Apply distance attenuation`,
            `            light = light / ((1.0 + uAttenConstant4) + lightDist * uAttenLinear4 + lightDist * lightDist * uAttenQuadratic4);`,
            `            `,
            `            // Accumulate light contribution`,
            `            sumColor = sumColor + light * uColor4 * uBrightness4;`,
            `            `,
            `            // Calculate specular if enabled`,
            `            if (uSpecularEnable > 0.5) {`,
            `                highp vec3 reflectDir = reflect(-lightDir, lightNormal);`,
            `                highp float spec = pow(max(dot(viewDir, reflectDir), 0.0), uShininess);`,
            `                specularSum += uSpecularIntensity * spec * spot / ((1.0 + uAttenConstant4) + lightDist * uAttenLinear4 + lightDist * lightDist * uAttenQuadratic4);`,
            `            }`,
            `        }`,
            `        `,
            `        // Light 5 (spotlight)`,
            `        if (uEnable5 != 0.0) {`,
            `            highp vec3 lightPos = vec3(uPosX5, uPosY5, uPosZ5);`,
            `            highp vec3 spotDir = vec3(uSpotDirX5, uSpotDirY5, uSpotDirZ5);`,
            `            highp vec3 lightDir = pos - lightPos;`,
            `            highp float lightDist = length(lightDir);`,
            `            lightDir = normalize(lightDir);`,
            `            spotDir = normalize(spotDir);`,
            `            `,
            `            // Calculate diffuse lighting (match fragment shader: no negation)`,
            `            highp float dotNL = dot(lightNormal, lightDir);`,
            `            highp float light = dotNL * (1.0-wrap) + wrap;`,
            `            light = light * light;`,
            `            `,
            `            // Calculate spotlight cone attenuation`,
            `            highp float cutoff = uSpotAngle5;`,
            `            highp float edge = uSpotEdge5;`,
            `            highp float spot = dot(spotDir, lightDir);`,
            `            spot = spot < cutoff ? smoothstep(cutoff * (1.0 - edge), cutoff, spot) : 1.0;`,
            `            light = light * spot;`,
            `            `,
            `            // Apply distance attenuation`,
            `            light = light / ((1.0 + uAttenConstant5) + lightDist * uAttenLinear5 + lightDist * lightDist * uAttenQuadratic5);`,
            `            `,
            `            // Accumulate light contribution`,
            `            sumColor = sumColor + light * uColor5 * uBrightness5;`,
            `            `,
            `            // Calculate specular if enabled`,
            `            if (uSpecularEnable > 0.5) {`,
            `                highp vec3 reflectDir = reflect(-lightDir, lightNormal);`,
            `                highp float spec = pow(max(dot(viewDir, reflectDir), 0.0), uShininess);`,
            `                specularSum += uSpecularIntensity * spec * spot / ((1.0 + uAttenConstant5) + lightDist * uAttenLinear5 + lightDist * lightDist * uAttenQuadratic5);`,
            `            }`,
            `        }`,
            `        `,
            `        // Light 6 (spotlight)`,
            `        if (uEnable6 != 0.0) {`,
            `            highp vec3 lightPos = vec3(uPosX6, uPosY6, uPosZ6);`,
            `            highp vec3 spotDir = vec3(uSpotDirX6, uSpotDirY6, uSpotDirZ6);`,
            `            highp vec3 lightDir = pos - lightPos;`,
            `            highp float lightDist = length(lightDir);`,
            `            lightDir = normalize(lightDir);`,
            `            spotDir = normalize(spotDir);`,
            `            `,
            `            // Calculate diffuse lighting (match fragment shader: no negation)`,
            `            highp float dotNL = dot(lightNormal, lightDir);`,
            `            highp float light = dotNL * (1.0-wrap) + wrap;`,
            `            light = light * light;`,
            `            `,
            `            // Calculate spotlight cone attenuation`,
            `            highp float cutoff = uSpotAngle6;`,
            `            highp float edge = uSpotEdge6;`,
            `            highp float spot = dot(spotDir, lightDir);`,
            `            spot = spot < cutoff ? smoothstep(cutoff * (1.0 - edge), cutoff, spot) : 1.0;`,
            `            light = light * spot;`,
            `            `,
            `            // Apply distance attenuation`,
            `            light = light / ((1.0 + uAttenConstant6) + lightDist * uAttenLinear6 + lightDist * lightDist * uAttenQuadratic6);`,
            `            `,
            `            // Accumulate light contribution`,
            `            sumColor = sumColor + light * uColor6 * uBrightness6;`,
            `            `,
            `            // Calculate specular if enabled`,
            `            if (uSpecularEnable > 0.5) {`,
            `                highp vec3 reflectDir = reflect(-lightDir, lightNormal);`,
            `                highp float spec = pow(max(dot(viewDir, reflectDir), 0.0), uShininess);`,
            `                specularSum += uSpecularIntensity * spec * spot / ((1.0 + uAttenConstant6) + lightDist * uAttenLinear6 + lightDist * lightDist * uAttenQuadratic6);`,
            `            }`,
            `        }`,
            `        `,
            `        // Light 7 (spotlight)`,
            `        if (uEnable7 != 0.0) {`,
            `            highp vec3 lightPos = vec3(uPosX7, uPosY7, uPosZ7);`,
            `            highp vec3 spotDir = vec3(uSpotDirX7, uSpotDirY7, uSpotDirZ7);`,
            `            highp vec3 lightDir = pos - lightPos;`,
            `            highp float lightDist = length(lightDir);`,
            `            lightDir = normalize(lightDir);`,
            `            spotDir = normalize(spotDir);`,
            `            `,
            `            // Calculate diffuse lighting (match fragment shader: no negation)`,
            `            highp float dotNL = dot(lightNormal, lightDir);`,
            `            highp float light = dotNL * (1.0-wrap) + wrap;`,
            `            light = light * light;`,
            `            `,
            `            // Calculate spotlight cone attenuation`,
            `            highp float cutoff = uSpotAngle7;`,
            `            highp float edge = uSpotEdge7;`,
            `            highp float spot = dot(spotDir, lightDir);`,
            `            spot = spot < cutoff ? smoothstep(cutoff * (1.0 - edge), cutoff, spot) : 1.0;`,
            `            light = light * spot;`,
            `            `,
            `            // Apply distance attenuation`,
            `            light = light / ((1.0 + uAttenConstant7) + lightDist * uAttenLinear7 + lightDist * lightDist * uAttenQuadratic7);`,
            `            `,
            `            // Accumulate light contribution`,
            `            sumColor = sumColor + light * uColor7 * uBrightness7;`,
            `            `,
            `            // Calculate specular if enabled`,
            `            if (uSpecularEnable > 0.5) {`,
            `                highp vec3 reflectDir = reflect(-lightDir, lightNormal);`,
            `                highp float spec = pow(max(dot(viewDir, reflectDir), 0.0), uShininess);`,
            `                specularSum += uSpecularIntensity * spec * spot / ((1.0 + uAttenConstant7) + lightDist * uAttenLinear7 + lightDist * lightDist * uAttenQuadratic7);`,
            `            }`,
            `        }`,
            `        `,
            `        // Directional light`,
            `        if (uDirectionalEnable != 0.0) {`,
            `            highp vec3 lightDir = vec3(uDirectionalDirX, uDirectionalDirY, uDirectionalDirZ);`,
            `            lightDir = normalize(lightDir);`,
            `            `,
            `            // Calculate diffuse lighting (match fragment shader: no negation)`,
            `            highp float dotNL = dot(lightNormal, lightDir);`,
            `            highp float light = dotNL * (1.0-wrap) + wrap;`,
            `            light = light * light;`,
            `            `,
            `            // Accumulate light contribution (no distance attenuation for directional light)`,
            `            sumColor = sumColor + light * uDirectionalColor * uDirectionalBrightness;`,
            `            `,
            `            // Calculate specular if enabled`,
            `            if (uSpecularEnable > 0.5) {`,
            `                highp vec3 reflectDir = reflect(-lightDir, lightNormal);`,
            `                highp float spec = pow(max(dot(viewDir, reflectDir), 0.0), uShininess);`,
            `                specularSum += uSpecularIntensity * spec;`,
            `            }`,
            `        }`,
            `        `,
            `        `,
            `        // Add specular contribution (purely additive)`,
            `        sumColor = uAmbientColor + sumColor + specularSum * uSpecularColor;`,
            `        `,
            `        // Clamp final color to [0, 1] range`,
            `        vVertexLighting = clamp(sumColor*vColor.xyz, vec3(0.0), vec3(1.0));`,
            `    }`,
            `}`,
          ].join("\n")
        }
        console.info("[3DObject] allow gpu skinning")
        // Monkeypatch webgl_2 vertex shader
        C3.Gfx.WebGLShaderProgram.GetDefaultVertexShaderSource_WebGL2 = GetDefaultVertexShaderSource_WebGL2
        // Temp monkeypatch user shader during runtime for pos support (does not work in editor)
        const shader = globalThis["C3_Shaders"]["mikal_frag_light-8"]
        if (shader) {
          shader.glslWebGL2 = shader.glslWebGL2.replace(
            "in mediump vec2 vTex;",
            "in highp float vNPW;\nin mediump vec2 vTex;\nin highp vec3 pos;\nin lowp vec4 vColor;\nin highp vec3 vNormal;\nuniform highp float uPhongEnable;\nin highp vec2 vNPTex;\nin highp vec3 vVertexLighting;"
          )
          shader.glslWebGL2 = shader.glslWebGL2.replace("highp vec3 pos = vec3(0.0, 0.0, 0.0);", "")
          shader.glslWebGL2 = shader.glslWebGL2.replace("lowp vec4 vColor = vec4(0.0, 0.0, 0.0, 1.0);", "")
          shader.glslWebGL2 = shader.glslWebGL2.replace("highp vec3 vNormal = vec3(0.0, 0.0, 0.0);", "")
          shader.glslWebGL2 = shader.glslWebGL2.replace("highp float uPhongEnable = 0.0;", "")
          shader.glslWebGL2 = shader.glslWebGL2.replace("highp vec2 vNPTex = vec2(0.0, 0.0);", "")
          shader.glslWebGL2 = shader.glslWebGL2.replace("highp float vNPW = 0.0;", "")
          shader.glslWebGL2 = shader.glslWebGL2.replace("highp vec3 vVertexLighting = vec3(1.0, 1.0, 1.0);", "")

          console.info("[3DObject] patched shader mikal_frag_light-8 for vertex lighting")
          console.debug("vertex shader:\n", GetDefaultVertexShaderSource_WebGL2(true))
          console.debug("fragment shader:\n", shader.glslWebGL2)
        } else {
          console.warn("[3DObject] shader mikal_frag_light-8 not found")
        }
      }
    }

    Release() {
      super.Release()
    }
  }
}
